<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1.0" name="viewport">
      
        <title>Sorting Algorithms</title>
        <meta content="" name="description">
        <meta content="" name="keywords">
      
        <!-- Google Fonts -->
        <link href="https://fonts.googleapis.com/css?family=Poppins:300,300i,400,400i,500,500i,600,600i,700,700i|Playfair+Display:400,400i,500,500i,600,600i,700,700i,900,900i" rel="stylesheet">
      
        <!-- Vendor CSS Files -->
        <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
        <link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
        <link href="assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
        <link href="assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
        <link href="assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">


      
        <!-- Template Main CSS File -->
        <link href="assets/css/style.css" rel="stylesheet">
      </head>

<body>

  <!-- ======= Header ======= -->
  <header id="header" class="fixed-top ">
    <div class="container d-flex align-items-center justify-content-between">

      <a class="logo" href="index.html">Spandan Patel</a>
      <!-- Uncomment below if you prefer to use an text logo -->
      <!-- <h1 class="logo"><a href="index.html">Folio</a></h1> -->

      <nav id="navbar" class="navbar">
        <ul>
          <li><a class="nav-link scrollto" href="index.html">Home</a></li>
          <li><a class="nav-link scrollto" href="index.html#about">About</a></li>
          <li><a href="assets/resume/Spandan_Resume.pdf" target="_blank">Resume</a></li>
          <li><a class="nav-link  scrollto" href="index.html#professional">Professional Projects</a></li>
          <li><a class="nav-link  scrollto" href="index.html#personal">Personal Projects</a></li>
          <li><a class="nav-link scrollto" href="index.html#contact">Contact</a></li>
        </ul>
        <i class="bi bi-list mobile-nav-toggle"></i>
      </nav><!-- .navbar -->

    </div>
  </header><!-- End Header -->

  <main id="main">

    
    <!-- ======= Blog Single ======= -->
    <div class="main-content paddsection">
      <div class="container">
        <h1 style="padding-bottom: 10px; text-align: center;">Sorting Algorithms Visualizer</h1>
        <div class="row justify-content-center">
          <div class="col-md-12 col-md-offset-2">
            <div class="row">
              <div class="container-main single-main">
                <div class="col-md-12">
                  <div class="block-main mb-30">
                    <div class="content-main single-post padDiv">
                      <div class="journal-txt">
                        <div class="project-video">
                            <iframe src="https://www.youtube.com/embed/TKnv4g2ly7s?autoplay=1&mute=1">
                            </iframe>
                        </div>
                          <div style="padding-bottom: 10px;"></div>
                        <h4 style="color: #1f1f1f; font-size: 20px; padding-top: 5px;">Game Engine      - Unreal Engine, C++, Python</h4>
                        <h4 style="color: #1f1f1f; font-size: 20px; padding-top: 5px;">Learning Outcome - Implementation of Different Sorting Algorithms and their Visualization</h4>
                      </div>

                      <p><h4 style="color: #1f1f1f; font-size: 20px;">About the Project :</h4></p>

                        <ul>
                          <li>I implemented visualization of different sorting algorithms for comparing completion time, swap count, and much more of each algorithms.</li>
                          <li style="padding-top: 5px;">I also used shuffle system (Fisher-Yates Shuffle) to randomize data using seeds.</li>
                          <li style="padding-top: 5px;">Future Update - Web Player Demo and UI for others to visualize all functionality of project.</li>
                          <li style="padding-top: 5px;">More details about each algorithms and code Snippets are below.</li>
                        </ul>             
                        
                        <p><h4 style="color: #1f1f1f; font-size: 20px;">Comparison Table :</h4></p>
                        
                        <table style="width:100%">
  <tr>
    <th colspan="2"></th>
    <th>Selection</th>
    <th>Bubble</th>
    <th>Merge</th>
    <th>Insertion</th>
    <th>Quick</th>
    <th>Heap</th>
    <th>Count</th>
  </tr>
  <tr>
    <th rowspan="2">Random Seed 1</td>
    <th>Swaps</td>
    <td>198</td>
    <td>5046</td>
    <td>0</td>
    <td>0</td>
    <td>734</td>
    <td>1162</td>
    <td>0</td>
  </tr>
  <tr>
    <th>Time</td>
    <td>1.47s</td>
    <td>37.79s</td>
    <td>10.88s</td>
    <td>39.23s</td>
    <td>5.94s</td>
    <td>9.40s</td>
    <td>1.60s</td>
  </tr>
  
  <tr>
    <th rowspan="2">Random Seed 2</td>
    <th>Swaps</td>
    <td>198</td>
    <td>5224</td>
    <td>0</td>
    <td>0</td>
    <td>800</td>
    <td>1152</td>
    <td>0</td>
  </tr>
  <tr>
    <th>Time</td>
    <td>1.59s</td>
    <td>39.58s</td>
    <td>12.18s</td>
    <td>49.83s</td>
    <td>7.27s</td>
    <td>10.69s</td>
    <td>1.73s</td>
  </tr>
  
  <tr>
    <th rowspan="2">Random Seed 3</td>
    <th>Swaps</td>
    <td>198</td>
    <td>5096</td>
    <td>0</td>
    <td>0</td>
    <td>720</td>
    <td>1124</td>
    <td>0</td>
  </tr>
  <tr>
    <th>Time</td>
    <td>1.59s</td>
    <td>41.46s</td>
    <td>10.81s</td>
    <td>43.20s</td>
    <td>5.60s</td>
    <td>8.55s</td>
    <td>1.48s</td>
  </tr>
</table>

                      <p><h4 style="color: #1f1f1f; font-size: 20px;">Image Slicing using Python :</h4></p>

                      <pre class="prettyprint lang-py">
    from image_slicer import slice

    slice_count = 1000

    slice('filename.jpg', slice_count)
                                            </pre>
                      
                      <p><h4 style="color: #1f1f1f; font-size: 20px;">Fisher-Yates Shuffle :</h4></p>

                        <img class="img-fluid rounded mb-5" src="assets/img/shuffletiles.gif" alt="">

                        <pre class="prettyprint lang-cpp">
    void ATileManager::ShuffleTiles()
    {
        //set seed value form randinit
        FMath::RandInit(SeedNumber);
    
        for (int i = AllTiles.Num() - 1; i > 0; i--)
        {
            //get random number between 0 and i
            int j = FMath::Rand() % (i + 1);
    
            //swap tile position and index
            SwapTiles(AllTiles[i], AllTiles[j]);
        }
                          
        //TempArray = AllTiles;
    }
                        </pre>

                        <p><h4 style="color: #1f1f1f; font-size: 20px;">Selection Sort :</h4></p>

                        <img class="img-fluid rounded mb-5" src="assets/img/selectionsort.gif" alt="">

                        <pre class="prettyprint lang-cpp">
    if (CurrentSort == ESortType::SELECTION)
    {
        //float StartTime = GetWorld()->GetTimeSeconds();
                        
        //temp index for comparison
        int MinIndex;
                        
        for (int i = 0; i < AllTiles.Num() - 1; i++)
        {
            MinIndex = i;
                        
            //compare temp index with rest of indeces
            for (int j = i + 1; j < AllTiles.Num(); j++)
            {
                if (AllTiles[j]->GetTileIndex() < AllTiles[MinIndex]->GetTileIndex())
                    MinIndex = j;
                        
            }
                        
            //add tiles to array for visualization
            TileSwap1.Add(AllTiles[MinIndex]);
            TileSwap2.Add(AllTiles[i]);
                        
            //swap tile i with temp index
            SwapTileIndeces(AllTiles[MinIndex], AllTiles[i]);
     
            //GetWorldTimerManager().SetTimer(SwapTimer, this, &ATileManager::SwapTilesTimer, 0.001f, true);
            //SwapTiles(AllTiles[MinIndex], AllTiles[i]);
        }
     
        //float EndTime = GetWorld()->GetTimeSeconds();
                        
        //GEngine->AddOnScreenDebugMessage(-1, 2.f, FColor::Orange, FString::Printf(TEXT("%f"), (EndTime - StartTime) * 100000000.0f));
    }

  </pre>

  <p><h4 style="color: #1f1f1f; font-size: 20px;">Bubble Sort :</h4></p>

  <img class="img-fluid rounded mb-5" src="assets/img/bubblesort.gif" alt="">

  <pre class="prettyprint lang-cpp">
    else if (CurrentSort == ESortType::BUBBLE)
    {
        //float StartTime = GetWorld()->GetTimeSeconds();
  
        //bool to check inner loop caused any swaps or not	
        //if not, means array is sorted
        bool Swapped;
  
        for (int i = 0; i < AllTiles.Num() - 1; i++)
        {
            Swapped = false;
  
            for (int j = 0; j < AllTiles.Num() - i - 1; j++)
            {
                //compare j item with j + 1 item 
                if (AllTiles[j]->GetTileIndex() > AllTiles[j + 1]->GetTileIndex())
                {
                    //add tiles to array for visualization
                    TileSwap1.Add(AllTiles[j]);
                    TileSwap2.Add(AllTiles[j + 1]);
  
                    //swap tiles
                    SwapTileIndeces(AllTiles[j], AllTiles[j + 1]);
            
                    //GetWorldTimerManager().SetTimer(SwapTimer, this, &ATileManager::SwapTilesTimer, 0.001f, true);
                    //SwapTiles(AllTiles[j], AllTiles[j + 1]);
  
                    Swapped = true;
                }
            }
  
            //no swaps in inner loop, so break outer loop to stop sorting
            if (!Swapped)
                break;
        }
  
        //float EndTime = GetWorld()->GetTimeSeconds();
  
        //GEngine->AddOnScreenDebugMessage(-1, 2.f, FColor::Orange, FString::Printf(TEXT("%f"), (EndTime - StartTime) * 1000000.0f));
    }
  </pre>

    <p><h4 style="color: #1f1f1f; font-size: 20px;">Insertion Sort :</h4></p>

  <img class="img-fluid rounded mb-5" src="assets/img/insertionsort.gif" alt="">

  <pre class="prettyprint lang-cpp">
    else if (CurrentSort == ESortType::INSERTION)
    {
        //temp array
        auto* TempArray = new uint16[AllTiles.Num()];

        for (int i = 0; i < AllTiles.Num(); i++)
            TempArray[i] = AllTiles[i]->GetTileIndex();
            
        //temp key for current item
        int Key, j;
        
        for (int i = 1; i < AllTiles.Num(); i++)
        {
            //setting key
            Key = TempArray[i];
            
            //setting inner loop item index
            j = i - 1;
            
            //cheking item [0, 1,...j] with key
            //if item j index is greater than key
            //add j item to j + 1 index
            while (j >= 0 && TempArray[j] > Key)
            {
                //add tiles to array for visualization
                TempArrayTiles.Add(AllTiles[j + 1]);
                TempArrayIndexNew.Add(TempArray[j]);
                TempArrayPosition.Add(FindLocationOfIndex(TempArray[j]));
                
                TempArray[j + 1] = TempArray[j];
                
                j = j - 1;
              
            }
            
            //loop break if j item is smaller than key
            //then add key to j + 1 index
            
            //add tiles to array for visualization
            TempArrayTiles.Add(AllTiles[j + 1]);
            TempArrayIndexNew.Add(Key);
            TempArrayPosition.Add(FindLocationOfIndex(Key));
            
            TempArray[j + 1] = Key;
        }
    }
                        </pre>

                        <p><h4 style="color: #1f1f1f; font-size: 20px;">Merge Sort :</h4></p>

  <img class="img-fluid rounded mb-5" src="assets/img/mergesort.gif" alt="">

  <pre class="prettyprint lang-cpp">
    else if (CurrentSort == ESortType::MERGE)
    {
        //temp array
        auto* TempArray = new uint16[AllTiles.Num()];
        
        for (int i = 0; i < AllTiles.Num(); i++)
            TempArray[i] = AllTiles[i]->GetTileIndex();
            
        //for (int i = 0; i < AllTiles.Num(); i++)
        //UE_LOG(LogTemp, Warning, TEXT("%d"), TempArray[i]);
        
        MergeSort(TempArray, 0, AllTiles.Num() - 1);
    }
    
    void ATileManager::MergeSort(uint16 TempArray[], int const FirstIndex, int const LastIndex)
    {
        if (FirstIndex >= LastIndex)
            return;
            
        auto MidIndex = FirstIndex + (LastIndex - FirstIndex) / 2;
        MergeSort(TempArray, FirstIndex, MidIndex);
        MergeSort(TempArray, MidIndex + 1, LastIndex);
        Merge(TempArray, FirstIndex, MidIndex, LastIndex);
        //ShowSortResult(FirstIndex, LastIndex);
    }
    
    //combining two array while sorting
    void ATileManager::Merge(uint16 TempArray[], int const Left, int const Mid, int const Right)
    {
        //size for left array, with mid index
        int const LeftArraySize = Mid - Left + 1;
        
        //size for right array, with mid + 1 index
        int const RightArraySize = Right - Mid;
        
        //initialize left and right array
        auto* LeftArray = new uint16[LeftArraySize];
        auto* RightArray = new uint16[RightArraySize];
        
        //setting left and right array value
        for (int i = 0; i < LeftArraySize; i++)
            LeftArray[i] = TempArray[Left + i];
            
        for (int j = 0; j < RightArraySize; j++)
            RightArray[j] = TempArray[Mid + 1 + j];
            
        //index for left and right sub-array
        int i = 0, j = 0;
        
        //index of merged array
        int IndexOfMergedArray = Left;
        
        //copy data from left and right array to merged array
        while (i < LeftArraySize && j < RightArraySize)
        {
            //if i index of left is smaller than j index of right
            //set i index of left as merged index of temp array
            if (LeftArray[i] <= RightArray[j])
            {
                //TempArrayIndexOld.Add(TempArray[IndexOfMergedArray]);
                
                //add tiles to array for visualization
                TempArrayTiles.Add(AllTiles[IndexOfMergedArray]);
                TempArrayIndexNew.Add(LeftArray[i]);
                TempArrayPosition.Add(FindLocationOfIndex(LeftArray[i]));
                
                //setting i index of left as merged index of temp
                TempArray[IndexOfMergedArray] = LeftArray[i];
                i++;
            }
            
            //if i index of left is bigger than j index of right
            //set j index of right as merged index of temp array
            else
            {
                //TempArrayIndexOld.Add(TempArray[IndexOfMergedArray]);
                
                //add tiles to array for visualization
                TempArrayTiles.Add(AllTiles[IndexOfMergedArray]);
                TempArrayIndexNew.Add(RightArray[j]);
                TempArrayPosition.Add(FindLocationOfIndex(RightArray[j]));
                
                //setting j index of right as merged index of temp
                TempArray[IndexOfMergedArray] = RightArray[j];
                j++;
            }
            
            IndexOfMergedArray++;
        }
        
        //checking if any item from left array is left to add in merged array
        while (i < LeftArraySize)
        {
            //TempArrayIndexOld.Add(TempArray[IndexOfMergedArray]);
            TempArrayTiles.Add(AllTiles[IndexOfMergedArray]);
            TempArrayIndexNew.Add(LeftArray[i]);
            TempArrayPosition.Add(FindLocationOfIndex(LeftArray[i]));
            TempArray[IndexOfMergedArray] = LeftArray[i];
            i++;
            IndexOfMergedArray++;
        }
        
        //checking if any item from right array is left to add in merged array
        while (j < RightArraySize)
        {
            //TempArrayIndexOld.Add(TempArray[IndexOfMergedArray]);
            TempArrayTiles.Add(AllTiles[IndexOfMergedArray]);
            TempArrayIndexNew.Add(RightArray[j]);
            TempArrayPosition.Add(FindLocationOfIndex(RightArray[j]));
            TempArray[IndexOfMergedArray] = RightArray[j];
            j++;
            IndexOfMergedArray++;
        }
    }
  </pre>

  <p><h4 style="color: #1f1f1f; font-size: 20px;">Quick Sort :</h4></p>

  <img class="img-fluid rounded mb-5" src="assets/img/quicksort.gif" alt="">

  <pre class="prettyprint lang-cpp">
    void ATileManager::QuickSort(int LowIndex, int HighIndex)
    {
        if (LowIndex < HighIndex)
        {
            //pivot index, as pivot index is in correct sorted position
            int PivotIndex = Partition(LowIndex, HighIndex);
            
            //sort array before pivot index
            QuickSort(LowIndex, PivotIndex - 1);
            
            //sort array after pivot index
            QuickSort(PivotIndex + 1, HighIndex);
        }
    }

    int ATileManager::Partition(int LowIndex, int HighIndex)
    {
        //set pivot at last item
        int PivotIndex = AllTiles[HighIndex]->GetTileIndex();
        
        //set i index as low index - 1
        //correct index of pivot for now
        int i = LowIndex - 1;
        
        for (int j = LowIndex; j <= HighIndex - 1; j++)
        {
            //if j item is smaller than pivot, swap j item to i item
            if (AllTiles[j]->GetTileIndex() < PivotIndex)
            {
                //increment low index, i.e increment correct position of pivot
                i++;
                
                //add tiles for visualization
                TileSwap1.Add(AllTiles[i]);
                TileSwap2.Add(AllTiles[j]);
                
                //swap items
                SwapTileIndeces(AllTiles[i], AllTiles[j]);
            }
        }
        
        //now swap pivot to i + 1 index, as i + 1 is correct position of pivot
        
        //add tiles for visualization
        TileSwap1.Add(AllTiles[i + 1]);
        TileSwap2.Add(AllTiles[HighIndex]);
        
        //swap items
        SwapTileIndeces(AllTiles[i + 1], AllTiles[HighIndex]);
        
        //return correct index of pivot
        return (i + 1);
    }
                        </pre>

                        <p><h4 style="color: #1f1f1f; font-size: 20px;">Heap Sort :</h4></p>

  <img class="img-fluid rounded mb-5" src="assets/img/heapsort.gif" alt="">

  <pre class="prettyprint lang-cpp">
    void ATileManager::HeapSort(int Size)
    {
        //build heap
        for (int i = (Size / 2) - 1; i >= 0; i--)
            Heapify(Size, i);
            
        //remove root node one by one from heap
        for (int i = Size - 1; i > 0; i--)
        {
            //move root node to last
            
            //add tiles for visualization
            TileSwap1.Add(AllTiles[0]);
            TileSwap2.Add(AllTiles[i]);
            
            //swap items
            SwapTileIndeces(AllTiles[0], AllTiles[i]);
            
            //call max heapify on reduced heap 
            Heapify(i, 0);
        }
    }

    void ATileManager::Heapify(int Size, int Node)
    {
        //Root node as largest
        int Largest = Node;

        int Left = 2 * Node + 1;
        int Right = 2 * Node + 2;
        
        //if left node is greater than largest, then largest is equal to left node
        if (Left < Size && AllTiles[Left]->GetTileIndex() > AllTiles[Largest]->GetTileIndex())
            Largest = Left;
            
        //if right node is greater than largest, then largest is equal to right node
        if (Right < Size && AllTiles[Right]->GetTileIndex() > AllTiles[Largest]->GetTileIndex())
            Largest = Right;
            
        //if largest not root node
        if (Largest != Node)
        {
            //add tiles for visualization
            TileSwap1.Add(AllTiles[Node]);
            TileSwap2.Add(AllTiles[Largest]);
            
            //swap tiles
            SwapTileIndeces(AllTiles[Node], AllTiles[Largest]);
            
            //heapify the sub tree
            Heapify(Size, Largest);
        }
    }
                        </pre>

                        <p><h4 style="color: #1f1f1f; font-size: 20px;">Count Sort :</h4></p>

  <img class="img-fluid rounded mb-5" src="assets/img/countsort.gif" alt="">

  <pre class="prettyprint lang-cpp">
    void ATileManager::CountSort()
    {
        //set first element as max
        int Max = AllTiles[0]->GetTileIndex();
        
        //find max element from array
        for (int i = 1; i < AllTiles.Num(); i++)
        {
            if (AllTiles[i]->GetTileIndex() > Max)
                Max = AllTiles[i]->GetTileIndex();
        }
        
        //set first element as min
        int Min = AllTiles[0]->GetTileIndex();
        
        //find min element from array
        for (int i = 1; i < AllTiles.Num(); i++)
        {
            if (AllTiles[i]->GetTileIndex() < Min)
                Min = AllTiles[i]->GetTileIndex();
        }
        
        //get range
        int Range = Max - Min + 1;
        
        //create new count array
        TArray<int> Count;
          
        //create new temp array
        auto* TempArray = new int[AllTiles.Num()];
        
        //add 0 in count Tarray, to create Tarray of range number of element
        for (int i = 0; i <= Range; i++)
        {
            Count.Add(0);
        }
        
        //store count of each element inside count array
        for (int i = 0; i < AllTiles.Num(); i++)
        {
            Count[AllTiles[i]->GetTileIndex() - Min]++;
        }
        
        //set the count of each index by adding the count of previos index
        for (int i = 1; i < Count.Num(); i++)
        {
            Count[i] += Count[i - 1];
        }
        
        for (int i = AllTiles.Num() - 1; i >= 0; i--)
        {
            //find i element of main array in count array
            //set position of i in temp array based on position found in count array
            TempArray[Count[AllTiles[i]->GetTileIndex() - Min] - 1] = AllTiles[i]->GetTileIndex();
            
            //decresing the count of (i - min) element in count array
            Count[AllTiles[i]->GetTileIndex() - Min]--;
        }
        
        //add tiles for visualization
        for (int i = 0; i < AllTiles.Num(); i++)
        {
            TempArrayTiles.Add(AllTiles[i]);
            TempArrayIndexNew.Add(TempArray[i]);
            TempArrayPosition.Add(FindLocationOfIndex(TempArray[i]));
        }
    }
                        </pre>

                        <p><h4 style="color: #1f1f1f; font-size: 20px;">Resources :</h4></p>

                        <ul>
                          <li><b>Sorting Algorithms - </b><a href="https://www.geeksforgeeks.org/sorting-algorithms/" target="_blank">https://www.geeksforgeeks.org/sorting-algorithms/</a></li>
                        </ul>
                      
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div><!-- End Blog Single -->

  </main><!-- End #main -->

  <!-- ======= Footer ======= -->
  <!-- ======= Footer ======= -->
  <div id="footer" class="text-center">
    <div class="container">
      <p>&copy;All rights reserved by Spandan Patel.</p>
    </div>
  </div><!-- End Footer --><!-- End Footer -->

  <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>

  <!-- Vendor JS Files -->
  <script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="assets/vendor/glightbox/js/glightbox.min.js"></script>
  <script src="assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
  <script src="assets/vendor/swiper/swiper-bundle.min.js"></script>
  <script src="assets/vendor/typed.js/typed.min.js"></script>
  <script src="assets/vendor/php-email-form/validate.js"></script>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

  <!-- Template Main JS File -->
  <script src="assets/js/main.js"></script>

</body>

</html>